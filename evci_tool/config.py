# AUTOGENERATED! DO NOT EDIT! File to edit: ../00_config.ipynb.

# %% auto 0
__all__ = ['model_sheets', 'sites_sheets', 'traffic_sheets', 'grid_sheets', 'setup_and_read_data', 'data_availability_check',
           'data_integrity_check', 'read_globals']

# %% ../00_config.ipynb 5
import os
import numpy as np
import pandas as pd
import json


def setup_and_read_data(corridor:str, input_path='input/', output_path='output/'):
    "This function sets up paths and reads input excel files for a specified corridor"

    INPUT_PATH = input_path + corridor + '/'
    OUTPUT_PATH = output_path + corridor + '/'

    if not os.path.exists(OUTPUT_PATH):
        os.mkdir (output_path + corridor)
        
    model   = pd.read_excel(input_path + "model.xlsx",sheet_name=['charger_specific','battery_specific','others'])
    sites   = pd.read_excel(INPUT_PATH + "sites.xlsx",sheet_name=['sites'])
    traffic = pd.read_excel(INPUT_PATH + "traffic.xlsx",sheet_name=['profile'])
    grid    = pd.read_excel(INPUT_PATH + "grid.xlsx",sheet_name=['grid'])
    
    return model, sites, traffic, grid, INPUT_PATH, OUTPUT_PATH

# %% ../00_config.ipynb 9
model_sheets = ['charger_specific', 'battery_specific', 'others']
sites_sheets = ['sites']
traffic_sheets = ['profile']
grid_sheets = ['grid']

def data_availability_check(m,s,t,g): 
    "This function checks if the excel files contain the mandatory worksheets."
    
    retval = []
    
    if list(m.keys()) != model_sheets: retval.append('model')
    if list(s.keys()) != sites_sheets: retval.append('sites')
    if list(t.keys()) != traffic_sheets: retval.append('traffic')
    if list(g.keys()) != grid_sheets: retval.append('grid')
    
    #assert data_availability_check(list(m.keys()),model_sheets) == True, \
    #  f"model.xlsx must contain the sheets: {model_sheets}" 
    #assert data_availability_check(list(s.keys()),['sites']) == True, \
    #  f"sites.xlsx must contain the sheet {sites_sheets}" 
    #assert data_availability_check(list(t.keys()),['profile']) == True, 
    #  f"traffic.xlsx must contain the sheet {traffic_sheets}" 
    #assert data_availability_check(list(g.keys()),['grid']) == True, \
    #  f"grid.xlsx must contain the sheet {grid_sheets}"
    
    return retval

# %% ../00_config.ipynb 13
def data_integrity_check(m,s,t,g, verbose=False):
    "This function checks for integrity of excel data by checking missing values."
    missing = []
    
    for x in [m,s,t,g]:
        tmpx = {}
        for k in x.keys():
            total = x[k].shape[0]
            tmpx[k] = []
            for c in x[k].columns:
                if sum(pd.isna(x[k][c])) > 0:
                    if verbose: print(f"Column '{c}' of '{k}' has {sum(pd.isna(x[k][c]))}/{total} missing values")
                    tmpx[k].append(c)
        missing.append(tmpx)
                    
    return missing

# %% ../00_config.ipynb 18
def read_globals(m,s,t,g,ui_inputs):
    "This function returns all global parameters read from the xlsx."
    
    r = {}
    df_c = m['charger_specific']
    df_b = m['battery_specific']
    df_o = m['others']
    
    # read all other parameters from the xlsx
    
    r['M'] = df_c[df_c['Parameter']=='vehicle_types']['Value'].iloc[0].split(',')
    # or should it be from the UI having selected a subset for analysis?
    r['M'] = ui_inputs['M']
    r['C'] = df_c[df_c['Parameter']=='charger_types']['Value'].iloc[0].split(',')
    r['Kj'] = eval(df_c[df_c['Parameter']=='Kj']['Value'].iloc[0])
    r['Dj'] = eval(df_c[df_c['Parameter']=='Dj']['Value'].iloc[0])
    r['Hj'] = eval(df_c[df_c['Parameter']=='Hj']['Value'].iloc[0])
    r['Qj'] = eval(df_c[df_c['Parameter']=='Qj']['Value'].iloc[0])
    r['tj'] = eval(df_c[df_c['Parameter']=='tj']['Value'].iloc[0])
    r['Mj'] = eval(df_c[df_c['Parameter']=='Mj']['Value'].iloc[0])
    r['Gk'] = eval(df_c[df_c['Parameter']=='Gk']['Value'].iloc[0])

    r['N'] = 500
    r['Ng'] = 0

    r['timeslots'] = {k: 24/v for k, v in r['tj'].items()}
    timeslots = r['timeslots']
    
    r['Nc'] = s['sites'].shape[0]
    Nc = r['Nc']

    r['Gi'] = [0]*Nc
    r['di'] = [0]*Nc
    r['Wi'] = [0]*Nc
    r['Ri'] = [0]*Nc
    r['Ai'] = [50]*Nc
    r['Li'] = [1500]*Nc
    r['Bi'] = [0.25 * 3.5 * 24 * 365]*Nc # 25% of Rs 3.5/KWh per year

    r['Eg'] = {k: [5.5] * int(v) for k, v in timeslots.items()}
    r['Er'] = {k: [0] * int(v) for k, v in timeslots.items()}
    r['Mg'] = {k: [5.5 * 0.15] * int(v) for k, v in timeslots.items()}
    r['Mr'] = {k: [0] * int(v) for k, v in timeslots.items()}
    r['l']  = {k: [1] * int(v) for k, v in timeslots.items()}
    
    r['MH'] = [s['sites'].loc[i]['Hoarding margin'] for i in range(Nc)]
    r['MK'] = [0.15]*Nc

    #Traffic Model
    # read hourly vehicular traffic from the traffic.xlsx else use default values
    # peak vehicles through crowded junctions in a day ~ 1.5L

    peak_traffic = [
             4826, 4826, 5228, 5228, 5228, 5630, 6434, 6836, 6836, 
             6434, 6032, 6032, 6032, 6032, 6434, 6836, 7239, 8043, 
             8043, 8043, 6836, 6032, 5630, 5228       
    ]

    if 'profile' in t:
      r['peak_traffic'] = t['profile'].vehicles.tolist()[:24] 
      peak_traffic = r['peak_traffic']
    else:
      printf("Using default traffic profile of around 55000 vehicles per day")
      r['peak_traffic'] = peak_traffic

    # Average traffic approx 80% of peak
    avg_traffic = [i*.8 for i in peak_traffic]
    
    avg_traffic_3W = [i*.4 for i in avg_traffic]
    avg_traffic_4W = [i*.2 for i in avg_traffic]
  
    djworking_hourly_3WS = [i/5 for i in avg_traffic_3W]
    djworking_hourly = [i/5 for i in avg_traffic_4W]
    djworking_half_hourly = [val for val in djworking_hourly 
                             for _ in (0, 1)]
    djworking_one_and_half_hourly = list(np.mean(np.array(djworking_half_hourly).reshape(-1, 3), axis=1))
    r['djworking_hourly'] = djworking_hourly
    r['djworking_half_hourly'] = djworking_half_hourly
    r['djworking_one_and_half_hourly'] = djworking_one_and_half_hourly
    
    djworking = {}
    djworking['3WS'] = [np.round(i,0) for i in djworking_hourly_3WS]
    djworking['4WF'] = [np.round(i,0) for i in djworking_half_hourly]
    djworking['4WS'] = [np.round(i,0) for i in djworking_one_and_half_hourly]
    r['djworking'] = djworking        

    r['Cij'] = {'3WS':[1]*Nc, '4WS': [1]*Nc, '4WF':[1]*Nc}
    
    # now override the defaults with the read values from the UI parameters into r
    x = json.dumps(ui_inputs)
    ui_inputs = json.loads(x)
    
    r['K'] = ui_inputs['years_of_analysis']
    r['charger_types'] = ui_inputs['M']
    r['years_of_analysis'] = ui_inputs['years_of_analysis']
    r['capex_3WS'] = ui_inputs['capex_3WS']
    r['capex_4WS'] = ui_inputs['capex_4WS']
    r['capex_4WF'] = ui_inputs['capex_4WF']
    r['hoarding_cost'] = 900000
    r['kiosk_cost'] = 180000
    r['year1_conversion'] = ui_inputs['year1_conversion']
    r['year2_conversion'] = ui_inputs['year2_conversion']
    r['year3_conversion'] = ui_inputs['year3_conversion']
    r['fast_charging'] = ui_inputs['fast_charging']
    r['slow_charging'] = ui_inputs['slow_charging']
    r['holiday_percentage'] = ui_inputs['holiday_percentage']
    
    # now lets derive all other parameters that depend on the UI inputs.
    r['CH'] = [r['hoarding_cost']]*Nc
    r['CK'] = [r['kiosk_cost']]*Nc
    r['pj'] = {1: r['year1_conversion'], 
          2: r['year2_conversion'], 
          3: r['year3_conversion']}

    r['Pj'] = max(r['pj'].values()) 

    holiday_percentage = r['holiday_percentage']
    djholiday = {}
    djholiday['3WS'] = [np.round(i*holiday_percentage,0) for i in djworking_hourly_3WS]
    djholiday['4WF'] = [np.round(i*holiday_percentage,0) for i in djworking_half_hourly]
    djholiday['4WS'] = [np.round(i*holiday_percentage,0) for i in djworking_one_and_half_hourly]
    r['djholiday'] = djholiday
    
    fast_charging = float(df_o[df_o['Parameter']=='slow charger margin']['Value'].iloc[0])
    slow_charging = float(df_o[df_o['Parameter']=='fast charger margin']['Value'].iloc[0])

    r['qjworking'] = {'4WS': [slow_charging] * int(timeslots['4WS']), 
                 '4WF': [fast_charging] * int(timeslots['4WF']), 
                 '3WS': [fast_charging + slow_charging] * int(timeslots['3WS']), 
                  }
    r['qjholiday'] = {'4WS': [slow_charging] * int(timeslots['4WS']), 
                 '4WF': [fast_charging] * int(timeslots['4WF']), 
                 '3WS': [fast_charging + slow_charging] * int(timeslots['3WS']), 
                 }
    
    return r
